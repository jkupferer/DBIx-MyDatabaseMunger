=head1 NAME

DBIx::MyDatabaseMunger - MariaDB/MySQL Database Management Utility

=head1 SYNOPSIS

Normal interface is through the mydbmunger command, but this class can also
be used directly.

    use DBIx::MyDatabaseMunger ();
    $dbmunger = new DBIx::MyDatabaseMunger ({
        connect => {
            schema => 'database',
            host => 'mysql.example.com',
            user => 'username',
            password => 'p4ssw0rd',
        },
        colname => {
            ctime => 'create_datetime',
            mtime => 'tstmp',
        },
    });
    $dbmunger->pull();
    $dbmunger->make_archive();
    $dbmunger->push();
        
=head1 DESCRIPTION

A collection of utilities to simplify complex database management tasks.

=cut

package DBIx::MyDatabaseMunger;
use strict;
use warnings;
use autodie;
use Storable qw(dclone freeze);

our $VERSION = 0.001;
our $DRYRUN = 0;
our $VERBOSE = 0;

# When running the todo list, do these things in this order.
use constant TODO_ACTIONS => qw(
drop_constraint
drop_trigger
drop_key
drop_column
drop_table
create_table
add_column
modify_column
add_key
add_constraint
create_trigger
);

=head1 CONSTRUCTOR

The constructor C<new DBIx::MyDatabaseMunger()> takes a hash reference of
options. These options include.

=over 4

=item C<archive_name_pattern>

Naming convention for archive tables. Takes a wildcard, '%' that will be the
source table name.

Default: C<%Archive>

=item C<colname>

A hash of column names for special handling. Column names include:

=over 4

=item C<action>

Column used to record action in archive table. Column should be an enumeration
type with values 'insert', 'update', or 'delete'.

=item C<ctime>

Column used to record when a record is initially created. If not specified
then this functionality will not be implemented.

=item C<dbuser>

Column used to track dabase connection C<USER()>, which indicates the user and
host that is connected to the database.

=item C<mtime>

Column used to record when a record was last changed. If not specified then
this functionality will not be implemented.

=item C<revision>

Revision count column. Must be an integer type.

=item C<stmt>

The column used to track the SQL statement responsible for a table change.

=item C<updid>

The column used to store the value of the variable indicated by C<updidvar>.

=back

=item C<dir>

Directory in which to save table and trigger definitions.

Default: C<.>

=item C<updidvar>

Connection variable to be used by the calling application to track the reason
for table updates, inserts, and deletes.

Default: C<@updid>

=back

=cut

sub new
{
    my $class = shift;

    my $self = dclone( $_[0] );

    # Apply default values.
    $self->{dir} ||= '.';
    $self->{archive_name_pattern} ||= '%Archive';
    $self->{updidvar} ||= '@updid';
    $self->{colname}{action}      ||= 'action';
    $self->{colname}{dbuser}      ||= 'dbuser';
    $self->{colname}{revision}    ||= 'revision';
    $self->{colname}{stmt}        ||= 'stmt';
    $self->{colname}{updid}       ||= 'updid';

    return bless $self, $class;
}

=head1 METHODS

=over 4

=item C<table_names ()>

Return a list of all saved table names.

=cut

sub table_names :method
{
    my $self = shift;
    my @names;

    opendir my $dh, "$self->{dir}/table";
    while( my $table_sql = readdir $dh ) {
        my($name) = $table_sql =~ m/^(.*)\.sql$/
            or next;
        push @names, $name;
    };

    return @names;
}

=item $o->parse_create_table_sql ( $sql )

Parse a CREATE TABLE statement generated by mysql "SHOW CREATE TABLE ..."

This function is very particular about the input format.

=cut

sub parse_create_table_sql :method
{
    my $self = shift;
    my($sql) = @_;

    my @create_sql = split "\n", $sql;

    # Read the table name from the "CREATE TABLE `<NAME>` (
    shift( @create_sql ) =~ m/CREATE TABLE `(.*)`/ or die "Create table SQL does not begin with CREATE TABLE!\n";
    my $name = $1;

    # The last line should have the talbe options
    # ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='Application User.'
    # We don't need to understand every last option, but let's extract at least the
    # ENGINE and COMMENT.
    my $line = pop @create_sql;
    my($table_options) = $line =~ m/\)\s*(.*)/;

    # Extract the ENGINE= from the table options.
    $table_options =~ s/ENGINE=(\S+)\s*//
        or die "Table options lack ENGINE specification?!";
    my $engine = $1;

    # Drop data about AUTO_INCREMENT
    $table_options =~ s/AUTO_INCREMENT=(\d+)\s*//;

    # Extract the COMMENT and undo mysql ' quoting. We shouldn't have to deal
    # with weird characters or backslashes in comments, so let's keep it
    # simple.
    my $comment;
    if( $table_options =~ s/\s*COMMENT='(([^']|'')*)'// ) {
        $comment = $1;
        $comment =~ s/''/'/g;
    }

    # The remaining lines should be column definitions followed by keys.
    my @columns;
    my %column_definition;
    my @constraints;
    my %constraint_definition;
    my @keys;
    my %key_definition;
    my @primary_key;

    for my $line ( @create_sql ) {
        $line =~ s/,$//; # Strip trailing commas

        # Strip out DEFAULT NULL so that it is easier to compare column definitions.
        $line =~ s/ DEFAULT NULL//;

        if( $line =~ m/^\s*`([^`]+)`\s*(.*)/ ) {
            my($col,$def) = ($1,$2);
            push @columns, $col;
            $column_definition{ $col } = $def;
        } elsif( $line =~ m/^\s*PRIMARY KEY \(`(.*)`\)/ ) {
            @primary_key = split( '`,`', $1 );
        } elsif( $line =~ m/^\s*((UNIQUE )?KEY `([^`]+)`.*)/ ) {
            my($key,$def) = ($3,$1);
            push @keys, $key;
            $key_definition{ $key } = $def;
        } elsif( $line =~ m/^\s*CONSTRAINT\s+`(.*)` FOREIGN KEY \(`(.*)`\) REFERENCES `(.*)` \(`(.*)`\) *(.*)/ ) {
            my($name,$cols,$reftable,$refcols,$cascade_opt) = ($1,$2,$3,$4,$5);
            my @cols = split '`,`', $cols;
            my @refcols = split '`,`', $refcols;
            push @constraints, $name;
            $constraint_definition{ $name } = {
                columns => \@cols,
                reference_table => $reftable,
                reference_columns => \@refcols,
                cascade_opt => $cascade_opt,
            };
        } else {
            warn "Don't understand line in CREATE TABLE:\n$line";
        }
    }

    return {
        name => $name,
        comment => $comment,
        engine => $engine,
        table_options => $table_options,
        columns => \@columns,
        column_definition => \%column_definition,
        keys => \@keys,
        key_definition => \%key_definition,
        constraints => \@constraints,
        constraint_definition => \%constraint_definition,
        primary_key => \@primary_key,
    };
}

=item $o->read_table_sql ( $table_name )

Given a table name, retrieve the table definition SQL.

=cut

sub read_table_sql :method
{
    my $self = shift;
    my($name) = @_;

    # File slurp mode.
    local $/;

    open my $fh, "$self->{dir}/table/$name.sql";
    my $sql = <$fh>;
    close $fh;

    return $sql;
}

=item $o->get_table_desc ( $table_name )

Given a table name, retrieve the parsed table definition.

=cut

sub get_table_desc :method
{
    my $self = shift;
    my($name) = @_;

    my $sql = $self->read_table_sql( $name );
    my $desc;
    eval {
        $desc = $self->parse_create_table_sql( $sql );
    };
    die "Error parsing SQL for table `$name`:\n$@" if $@;
    die "Table name mismatch while reading SQL for `$name`, got `$desc->{name}` instead!\n"
        unless $name eq $desc->{name};

    return $desc;
}

=item $o->find_data_tables_with_revision ()

Return table definitions that have a revision column.

=cut

sub find_data_tables_with_revision ($)
{
    my $self = shift;

    my $archive_name_regexp = $self->{archive_name_pattern};
    $archive_name_regexp =~ s/%/.*/;
    $archive_name_regexp = qr/^$archive_name_regexp$/;

    my @tables = ();

    for my $name ( $self->table_names ) {
        # Skip tables that are archive_tables
        next if $name =~ $archive_name_regexp;

        my $table = $self->get_table_desc( $name );
        push @tables, $table
            if $table->{column_definition}{ $self->{colname}{revision} };
    }

    return @tables;
}

=item $o->check_table_is_archive_capable ( $table )

Check that a table has bare minimum support required to have an archive
table.

=cut

sub check_table_is_archive_capable :method
{
    my $self = shift;
    my ( $table ) = @_;

    die "$table->{name} lacks a primary key."
        unless @{$table->{primary_key}};

    my($col,$coldef);

    $col = $self->{colname}{revision};
    $coldef = $table->{column_definition}{$col}
        or die "$table->{name} lacks $col column.\n";
    $coldef =~ m/\b(int|bigint)\b/
        or die "$table->{name} column $col is not an integer type.\n";

    $col = $self->{colname}{updid};
    if( $table->{col_definition}{$col} ) {
        $coldef =~ m/\b(varchar)\b/
            or die "$table->{name} column $col is not a string type.\n";
    }

    for my $timecol (qw(mtime ctime)) {
        my $col = $self->{colname}{$timecol} or next;
        $coldef = $table->{column_definition}{$col}
            or die "$table->{name} lacks $col column.\n";
        $coldef =~ m/\b(timestamp|datetime)\b/
            or die "$table->{name} column $col is neither a timestamp or datetime field.\n";
    }

    # Check for obvious name conflicts.
    for my $col (qw(dbuser action stmt)) {
        die "Archive table column conflict, souce table `$table->{name}` has column `$col`.\n"
            if $table->{column_definition}{$col};
    }

    die "I can't promise this will work for table $table->{name} with ENGINE=$table->{engine}\n"
        unless $table->{engine} eq 'InnoDB';
}

=item $o->check_table_updatable( $current, $desired )

Check that the current table could be updated to the desired state.

=cut

sub check_table_updatable :method
{
    my $self = shift;
    my( $current, $desired ) = @_;
    my $name = $current->{name};

    die "Table `$name` lacks a primary key."
        unless @{$current->{primary_key}};

    die "Table `$name` primary key is not (`".join('`,`',@{$desired->{primary_key}})."`)\n"
        unless join('|',@{$current->{primary_key}}) eq join('|',@{$desired->{primary_key}});

    # Check for update paths between column definitions...
    for my $col ( @{$desired->{columns}} ) {
        my $cdef = $current->{column_definition}{$col};
        my $ddef = $desired->{column_definition}{$col};

        # It should be okay to add a column... though it may fail if it is
        # part of a unique index.
        next unless $cdef;

        my $num_type = qr/^((|tiny|small|medium|big)int|decimal|numeric|floadt|double)\b/;
        my $datetime_type = qr/^(date|datetime|timestamp)\b/;
        my $string_type = qr/^(char|varchar|binary|varbinary|(|tiny|medium|long)(blob|text)|enum|set)\b/;
        if( $ddef =~ $num_type ) {
            $cdef =~ $num_type or die "Table $name column $col is not a numeric type.\n";
        } elsif( $ddef =~ $datetime_type ) {
            $cdef =~ $datetime_type or die "Table $name column $col is not a datetime or timestamp type.\n";
        } elsif( $ddef =~ $string_type ) {
            $cdef =~ $string_type or die "Table $name column $col is not a string type.\n";
        }
    }

    die "Unable Table `$current->{name}`, engine mismatch $current->{engine} vs. $desired->{engine}\n"
        unless $current->{engine} eq $desired->{engine};
}
   

=item $o->make_archive_table_desc ( $table_desc )

Make a archive table description for the given source table description.

=cut

sub make_archive_table_desc :method
{
    my $self = shift;
    my( $table ) = @_;

    # Use name pattern to generate archive table names.
    my $name = $self->{archive_name_pattern};
    $name =~ s/%/$table->{name}/;

    my %archive_table = (
        name => $name,
        comment => "$table->{name} archive.",
        engine => $table->{engine},
        table_options => $table->{table_options},
        primary_key => [ @{$table->{primary_key}}, $self->{colname}{revision} ],
    );

    # Column definitions required for audit fields.
    my %column_definition = (
        $self->{colname}{dbuser} =>
            "varchar(256) NOT NULL COMMENT 'Database user & host that made this change.'",
        $self->{colname}{updid} =>
            "varchar(256) NOT NULL COMMENT 'Application user that made this change.'",
        $self->{colname}{action} =>
            "enum('insert','update','delete') NOT NULL COMMENT 'SQL action.'",
        $self->{colname}{stmt} =>
            "longtext NOT NULL COMMENT 'SQL Statement that initiated this change.'",
    );

    my @columns;
    for my $col ( @{ $table->{columns} } ) {
        push @columns, $col;
        my $def = $table->{column_definition}{$col};

        # Drop properties not appropriate for archive tables.
        $def =~ s/ AUTO_INCREMENT//;

        # Adjust timestamp defaults and update properties to remove
        # CURRENT_TIMESTAMP behavior.
        if( $def =~ m/^timestamp\b/ ) {
            $def =~ s/ ON UPDATE CURRENT_TIMESTAMP//;
            $def =~ s/ DEFAULT CURRENT_TIMESTAMP/ DEFAULT '0000-00-00 00:00:00'/;
        } elsif( ! grep { $col eq $_ } @{ $archive_table{primary_key} } ) {
            # Allow NULL and strip defaults for columns not part of the primary
            # key.
            $def =~ s/ DEFAULT '([^']|'')+'//;
            $def =~ s/ NOT NULL//;
        }

        $column_definition{ $col } = $def;
    }

    # Add columns required for archive fields.
    # Column definitions were given above.
    for my $col (qw(action updid dbuser stmt)) {
        my $colname = $self->{colname}{$col};
        # Skip columns already defined in the parent table.
        next if $table->{column_definition}{$colname};
        push @columns, $colname;
    }
    
    $archive_table{columns} = \@columns;
    $archive_table{column_definition} = \%column_definition;

    my @keys;
    my %key_definition;
    for my $key ( @{ $table->{keys} } ) {
        push @keys, $key;
        my $def = $table->{key_definition}{$key};

        # Strip unique property from keys.
        $def =~ s/^UNIQUE\s*//;

        $key_definition{$key} = $def;
    }

    $archive_table{keys} = \@keys;
    $archive_table{key_definition} = \%key_definition;
    
    return \%archive_table;
}

=item $o->write_table_sql( $name, $sql )

Save create table SQL for a table.

=cut

sub write_table_sql :method
{
    my $self = shift;
    my( $name, $sql ) = @_;
    my $fh;

    # Make table directory if required.
    mkdir "$self->{dir}/table"
        unless -d "$self->{dir}/table";

    open $fh, ">", "$self->{dir}/table/$name.sql";
    print $fh $sql;
    close $fh;
}

=item $o->write_table_definition( $table )

Write create table SQL for given table description.

=cut

sub write_table_definition :method
{
    my $self = shift;
    my( $table ) = @_;

    my $sql = "CREATE TABLE `$table->{name}` (\n";

    for my $col ( @{ $table->{columns} } ) {
        $sql .= "  `$col` $table->{column_definition}{$col},\n";
    }

    for my $key ( @{ $table->{keys} } ) {
        $sql .= "  $table->{key_definition}{$key},\n";
    }

    # Quote in a lazy way... to do it proper would require a database
    # connection.
    my $comment = $table->{comment} || $table->{name};
    $comment =~ s/'/''/g;

    $sql .= "  PRIMARY KEY (`".join('`,`', @{$table->{primary_key}} )."`)\n";
    $sql .= ") ENGINE=$table->{engine} $table->{table_options} COMMENT='$comment'\n";

    $self->write_table_sql( $table->{name}, $sql );
}

=item $o->write_trigger_fragment_sql( $name, $time, $action, $table, $sql )

Write trigger fragement SQL to a file.

=cut

sub write_trigger_fragment_sql :method
{
    my $self = shift;
    my( $name, $time, $action, $table, $sql ) = @_;
    my $fh;

    # Make trigger directory if required.
    mkdir "$self->{dir}/trigger"
        unless -d "$self->{dir}/trigger";

    open $fh, ">", "$self->{dir}/trigger/$name.$time.$action.$table.sql";
    print $fh $sql;
    close $fh;
}

=item $o->write_archive_trigger_fragments( $table, $archive_table_desc )

Write trigger fragment sql for archive table management.

=cut

sub write_archive_trigger_fragments :method
{
    my $self = shift;
    my( $table, $archive_table ) = @_;
    my $colname = $self->{colname};
    my $fragment;
    my $fh;

    # Make trigger directory if required.
    mkdir "$self->{dir}/trigger"
        unless -d "$self->{dir}/trigger";


    # Before insert
    $fragment = "SET NEW.`$colname->{revision}` = 0;\n";
    $fragment .= "SET NEW.`$colname->{ctime}` = CURRENT_TIMESTAMP;\n"
        if $colname->{ctime};
    $fragment .= "SET NEW.`$colname->{mtime}` = CURRENT_TIMESTAMP;\n"
        if $colname->{mtime};
    $fragment .= "SET NEW.`$colname->{updid}` = $self->{updidvar};\n"
        if $table->{column_definition}{ $colname->{updid} };
    $self->write_trigger_fragment_sql( "20-archive","before","insert",$table->{name},$fragment);


    # Before update
    $fragment = "SET NEW.`$colname->{revision}` = OLD.`$colname->{revision}` + 1;\n";
    $fragment .= "SET NEW.`$colname->{ctime}` = OLD.`$colname->{ctime}`;\n"
        if $colname->{ctime};
    $fragment .= "SET NEW.`$colname->{mtime}` = CURRENT_TIMESTAMP;\n"
        if $colname->{mtime};
    $fragment .= "SET NEW.`$colname->{updid}` = $self->{updidvar};\n"
        if $table->{column_definition}{ $colname->{updid} };
    $self->write_trigger_fragment_sql( "20-archive","before","update",$table->{name},$fragment);


    # Columns that don't receive special treatment.
    # Exclude columns with special names.
    my %namecol = map { $colname->{$_} ? ($colname->{$_} => $_) : () } keys %$colname;
    my @cols = grep { not $namecol{$_} } @{ $table->{columns} };

    # Special columns
    my @scols = grep { $colname->{$_} } sort keys %$colname;

    $fragment =
        "BEGIN DECLARE stmt longtext;\n" .
        "SET stmt = ( SELECT info FROM INFORMATION_SCHEMA.PROCESSLIST WHERE id = CONNECTION_ID() );\n" .
        "INSERT INTO `$archive_table->{name}` (\n" .
        "  `".join( '`, `', @cols, map { $colname->{$_} } @scols )."`\n".
        ") VALUES (\n";

    # After insert
    $self->write_trigger_fragment_sql( "40-archive","after","insert",$table->{name},$fragment.
        "  NEW.`".join('`, NEW.`', @cols)."`,\n" .
        "  ".join(', ', map {
            m/^(ctime|mtime|revision)$/ ? "NEW.`$colname->{$_}`" :
            $_ eq 'action'  ? "'insert'" :
            $_ eq 'updid'   ? $self->{updidvar} :
            $_ eq 'dbuser'  ? "USER()" :
            $_ eq 'stmt'    ? 'stmt' : die "BUG! $_ unhandled!"
        } @scols )."\n);\nEND;\n"
    );

    # After update
    $self->write_trigger_fragment_sql( "40-archive","after","update",$table->{name},$fragment.
        "  NEW.`".join('`, NEW.`', @cols)."`,\n" .
        "  ".join(', ', map {
            m/^(ctime|mtime|revision)$/ ? "NEW.`$colname->{$_}`" :
            $_ eq 'action'  ? "'update'" :
            $_ eq 'updid'   ? $self->{updidvar} :
            $_ eq 'dbuser'  ? "USER()" :
            $_ eq 'stmt'    ? 'stmt' : die "BUG! $_ unhandled!"
        } @scols )."\n);\nEND;\n"
    );

    # After delete
    $self->write_trigger_fragment_sql( "40-archive","after","delete",$table->{name},$fragment.
        "  OLD.`".join('`, OLD.`', @cols)."`,\n" .
        "  ".join(', ', map {
            $_ eq 'action'   ? "'update'" :
            $_ eq 'updid'    ? $self->{updidvar} :
            $_ eq 'ctime'    ? "OLD.`$colname->{ctime}`" :
            $_ eq 'dbuser'   ? "USER()" :
            $_ eq 'mtime'    ? "CURRENT_TIMESTAMP" :
            $_ eq 'revision' ? "1 + OLD.`$colname->{revision}`" :
            $_ eq 'stmt'     ? 'stmt' : die "BUG! $_ unhandled!"
        } @scols )."\n);\nEND;\n"
    );

}

=item $o->dbi_connect ()

Connect to the database.

=cut

sub dbi_connect :method
{
    my $self = shift;
    use DBI ();

    die "No database schema specified.\n"
        unless $self->{connect}{schema};

    # Build Perl DBI dsn
    my $dsn = "DBI:mysql:database=$self->{connect}{schema}";
    $dsn .= ";host=$self->{connect}{host}" if $self->{connect}{host};
    $dsn .= ";port=$self->{connect}{port}" if $self->{connect}{port};

    my $dbh = DBI->connect(
        $dsn,
        $self->{connect}{user},
        $self->{connect}{password},
        { PrintError => 0, RaiseError => 1 }
    );
    $self->{dbh} = $dbh;
}

=item $o->query_table_sql ( $name )

=cut

sub query_table_sql :method
{
    my $self = shift;
    my( $name ) = @_;
    my $dbh = $self->{dbh};

    my $sth = $dbh->prepare( "SHOW CREATE TABLE `$name`" );
    $sth->execute();
    my @row = $sth->fetchrow_array;

    return "$row[1]\n";
}

=item $o->pull_table_definition ( $name )

=cut

sub pull_table_definition :method
{
    my $self = shift;
    my( $name ) = @_;

    print "Pulling table definition for `$name`\n" if $VERBOSE;
 
    my $sql = $self->query_table_sql( $name );

    # Drop data about AUTO_INCREMENT
    $sql =~ s/(\).*)AUTO_INCREMENT=\d+\s*(.*)/$1$2/;

    $self->write_table_sql( $name, $sql );
}

=item $o->pull_table_definitions ()

=cut

sub pull_table_definitions :method
{
    my $self = shift;
    my $dbh = $self->{dbh};

    my $sth = $dbh->prepare( 'SHOW TABLES' );
    $sth->execute();

    # Make table directory if required.
    mkdir "$self->{dir}/table"
        unless -d "$self->{dir}/table";

    while( my($name) = $sth->fetchrow_array ) {
        pull_table_definition( $self, $name );
    }
}

=item $o->pull_trigger_definitions()

=cut

sub pull_trigger_definitions :method
{
    my $self = shift;
    my $dbh = $self->{dbh};
    
    my $list_sth = $dbh->prepare( 'SHOW TRIGGERS' );
    $list_sth->execute();

    my %triggers;
    while( my($trigger_name,$action,$table,$sql,$time) = $list_sth->fetchrow_array() ) {
        # Strip off BEGIN and END from trigger body
        $sql =~ s/^\s*BEGIN\s*(.*)END\s*$/$1/s;

        # Lowercase is easier to read
        $action = lc $action;
        $time = lc $time;

	$triggers{$table} ||= {};
	$triggers{$table}{$action} ||= {};
	$triggers{$table}{$action}{$time} = { sql => $sql, name => $trigger_name };
    }

    return %triggers;
}

=item $o->pull_trigger_fragments :method

=cut

sub pull_trigger_fragments :method
{
    my($self) = @_;

    my %triggers = pull_trigger_definitions( $self );

    for my $table ( sort keys %triggers ) {

        if( @{ $self->{tables} } ) {
            # Skip triggers for table based on explicit table list.
            next unless grep { $_ eq $table } @{ $self->{tables} };
        }

        for my $action ( sort keys %{$triggers{$table}} ) {
            for my $time ( sort keys %{$triggers{$table}{$action}} ) {
                my $trigger_sql = $triggers{$table}{$action}{$time}{sql};

                # Parse all tagged trigger fragments
                while( $trigger_sql =~ s{/\*\* begin (\S+) \*/\s*(.*)/\*\* end \1 \*/\s*}{}s ) {
                    my( $name, $sql ) = ($1,$2);
                    $self->write_trigger_fragment_sql( $name, $time, $action, $table, $sql );
                }

		# Handle any untagged trigger SQL?
                $trigger_sql =~ s/\s*$//;
                if( $trigger_sql ) {
                    if( $self->{init_trigger_name} ) {
                        $self->write_trigger_fragment_sql( $self->{init_trigger_name}, $time, $action, $table, $trigger_sql );
                    } else {
                        die "Found unlabeled trigger code for $time $action `$table`!\n$trigger_sql\nDo you need to specify --init-trigger-name=NAME?\n";
                    }
                }
            }
        }
    }
}

=item $o->pull ()

Handle the pull command.

=cut

sub pull :method
{
    my $self = shift;

    $self->dbi_connect();
    
    $self->pull_table_definitions();
    $self->pull_trigger_fragments();
}

=item $o->queue_create_table ( $table )

=cut

sub queue_create_table :method
{
    my $self = shift;
    my( $table ) = @_;
    my $todo = $self->{todo};
    my $dbh = $self->{dbh};

    my $sql = "CREATE TABLE `$table->{name}` (\n";

    for my $col ( @{ $table->{columns} } ) {
        $sql .= "  `$col` $table->{column_definition}{$col},\n";
    }

    for my $key ( @{ $table->{keys} } ) {
        $sql .= "  $table->{key_definition}{$key},\n";
    }

    $sql .= "  PRIMARY KEY (`".join('`,`', @{$table->{primary_key}} )."`)\n";
    $sql .= ") ENGINE=$table->{engine} $table->{table_options}";
    $sql .= " COMMENT=".$dbh->quote($table->{comment})
        if $table->{comment};

    push @{$todo->{create_table}}, {
        desc => "Create table $table->{name}.",
        sql => $sql,
    };

    for my $constraint ( @{$table->{constraints}} ) {
        $self->queue_add_table_constraint($table,$constraint);
    }
}

=item $o->queue_add_table_constraint ( $table, $constraint )

=cut

sub queue_add_table_constraint :method
{
    my $self = shift;
    my($table,$constraint) = @_;
    my $todo = $self->{todo};

    my $def = $table->{constraint_definition}{$constraint};
    push @{$todo->{add_constraint}}, {
        desc => "Add constraint $constraint on $table->{name}.",
        sql => "ALTER TABLE `$table->{name}` ADD CONSTRAINT `$constraint` FOREIGN KEY (`".join('`,`',@{$def->{columns}})."`) REFERENCES `$def->{reference_table}` (`".join('`,`',@{$def->{reference_columns}},)."`) ".$def->{cascade_opt},
    };

    return $self;
}

=item $o->queue_drop_table_constraint ( $table, $constraint )

=cut

sub queue_drop_table_constraint :method
{
    my $self = shift;
    my($table,$constraint) = @_;
    my $todo = $self->{todo};

    my $def = $table->{constraint_definition}{$constraint};
    push @{$todo->{drop_constraint}}, {
        desc => "Drop constraint $constraint on $table->{name}.",
        sql => "ALTER TABLE `$table->{name}` DROP FOREIGN KEY `$constraint`",
    };

    return $self;
}

=item $o->queue_table_updates( $current, $desired )

=cut

sub queue_table_updates :method
{
    my $self = shift;
    my($current,$new) = @_;
    my $todo = $self->{todo};

    for my $col ( @{ $new->{columns} } ) {
        if( $current->{column_definition}{$col} ) {
            unless( $current->{column_definition}{$col} eq $new->{column_definition}{$col} ) {
                push @{$todo->{modify_column}}, {
                    desc => "Modify column $col in $current->{name}\n",
                    sql => "ALTER TABLE `$current->{name}` MODIFY COLUMN `$col` $new->{column_definition}{$col}",
                };
            }
        } else {
            push @{$todo->{add_column}}, {
                desc => "Add column $col to $current->{name}.",
                sql => "ALTER TABLE `$current->{name}` ADD COLUMN `$col` $new->{column_definition}{$col}",
            };
        }
    }

    for my $key ( @{ $new->{keys} } ) {
        if( $current->{key_definition}{$key} ) {
            unless( $current->{key_definition}{$key} eq $new->{key_definition}{$key} ) {
                push @{$todo->{drop_key}}, {
                    desc => "Drop key $key on $current->{name}.",
                    sql => "ALTER TABLE `$current->{name}` DROP KEY `$key`",
                };
                push @{$todo->{add_key}}, {
                    desc => "Add key $key on $current->{name}.",
                    sql => "ALTER TABLE `$current->{name}` ADD $new->{key_definition}{$key}",
                };
            }
        } else {
            push @{$todo->{add_key}}, {
                desc => "Create key $key on $current->{name}.",
                sql => "ALTER TABLE `$current->{name}` ADD $new->{key_definition}{$key}",
            };
        }
    }

    for my $constraint ( @{$new->{constraints}} ) {
        if( ! $current->{constraint_definition}{$constraint}
        or freeze($current->{constraint_definition}{$constraint}) ne freeze($new->{constraint_definition}{$constraint}) ) {
            $self->queue_drop_table_constraint($current,$constraint)
                if $current->{constraint_definition}{$constraint};
            $self->queue_add_table_constraint($new,$constraint);
        }
    }
    for my $constraint ( @{$current->{constraints}} ) {
        next if $new->{constraint_definition}{$constraint};
        $self->queue_drop_table_constraint($current,$constraint);
    }
}

=item $o->push_table_definition( $table )

=cut

sub queue_push_table_definition :method
{
    my $self = shift;
    my($name) = @_;
    
    my $new_sql = $self->read_table_sql( $name );
    my $new = $self->parse_create_table_sql( $new_sql );

    my( $current, $current_sql );
    eval {
        $current_sql = $self->query_table_sql( $name );
        $current = $self->parse_create_table_sql( $current_sql );
    };

    if( $current ) {
        $self->queue_table_updates( $current, $new );
    } else {
        $self->queue_create_table( $new );
    }

}

=item $o->push_table_definitions()

=cut

sub queue_push_table_definitions :method
{
    my $self = shift;

    my @tables = @{ $self->{tables} };
    @tables = $self->table_names
	unless @tables;

    for my $table ( @tables ) {
        $self->queue_push_table_definition( $table );
    }
}


=item $o->assemble_triggers ()

=cut

sub assemble_triggers :method
{
    my $self = shift;

    my $dir = "$self->{dir}/trigger";
    return () unless -d $dir;
    my $dh;
    opendir $dh, $dir;

    my %triggers = ();
    while( my $file = readdir $dh ) {
        my($name,$time,$action,$table) =
            $file =~ m/^(.+)\.(before|after)\.(insert|update|delete)\.(.+)\.sql$/
            or next;

        # Slurp file.
        local $/;
        open my $fh, "<", "$dir/$file";
	my $sql = <$fh>;
	close $fh;

	$triggers{$table} ||= {};
	$triggers{$table}{$action} ||= {};
	$triggers{$table}{$action}{$time} ||= '';
	$triggers{$table}{$action}{$time} .= "/** begin $name */\n$sql/** end $name */\n";
    }

    return %triggers;
}

=item $o->queue_push_trigger_definitions()

=cut

sub queue_push_trigger_definitions :method
{
    my $self = shift;
    my $todo = $self->{todo};

    my %triggers = $self->assemble_triggers();
    my %current_triggers = $self->pull_trigger_definitions();

    for my $table ( sort keys %triggers ) {

        if( @{ $self->{tables} } ) {
            # Skip triggers for table based on explicit table list.
            next unless grep { $_ eq $table } @{ $self->{tables} };
        }

        for my $action ( sort keys %{$triggers{$table}} ) {
            for my $time ( sort keys %{$triggers{$table}{$action}} ) {
                my $new = $triggers{$table}{$action}{$time};
                my $current = $current_triggers{$table}{$action}{$time};

                my $create_sql = "CREATE TRIGGER `${time}_${action}_${table}` $time $action ON `$table` FOR EACH ROW BEGIN\n${new}END";

                if( not $current ) {
                    push @{$todo->{create_trigger}}, {
                        desc => "Create $time $action on $table trigger.",
                        sql => $create_sql,
		    };
                } elsif( $current->{sql} ne $new ) {
                    push @{$todo->{drop_trigger}}, {
                        desc => "Drop $time $action on $table trigger.",
                        sql => "DROP TRIGGER IF EXISTS `$current->{name}`",
		    };
                    push @{$todo->{create_trigger}}, {
                        desc => "Create $time $action on $table trigger.",
                        sql => $create_sql,
		    };
                }
            }
        }
    }

    # Check if any triggers should be dropped.
    for my $table ( sort keys %current_triggers ) {

        if( @{ $self->{tables} } ) {
            # Skip triggers for table based on explicit table list.
            next unless grep { $_ eq $table } @{ $self->{tables} };
        }

        for my $action ( sort keys %{$current_triggers{$table}} ) {
            for my $time ( sort keys %{$current_triggers{$table}{$action}} ) {
                next if $triggers{$table}{$action}{$time};
                my $trigger = $current_triggers{$table}{$action}{$time};

                push @{$todo->{drop_trigger}}, {
                    desc => "Drop $time $action on $table trigger.",
                    sql => "DROP TRIGGER IF EXISTS `$trigger->{name}`",
		};
            }
        }
    }
}

=item $o->push ()

Handle the push command.

=cut

sub push :method
{
    my $self = shift;
    my %todo = map {($_=>[])} TODO_ACTIONS;
    $self->{todo} = \%todo;

    $self->dbi_connect();
    
    $self->queue_push_table_definitions();
    $self->queue_push_trigger_definitions();

    my $count = 0;
    for my $action ( TODO_ACTIONS ) {
        for my $task ( @{$todo{$action}} ) {
            ++$count;
            print $task->{desc},"\n";
	    print "\n$task->{sql}\n\n" if $VERBOSE or $DRYRUN;
            eval {
                $self->{dbh}->do( $task->{sql} ) unless $DRYRUN;
            };
            die "Error executing SQL: $@\n$task->{sql}\n" if $@;
        }
    }

    if( $count == 0 ) {
        print "No updates need pushed.\n";
    }
}

=item $o->make_archive ()

Handle the make-archive command.

=cut

sub make_archive :method
{
    my $self = shift;

    # Detect tables by presence of revision column if option wasn't provided on
    # the command-line.
    my @tables_desc;
    if( @{ $self->{tables} } ) {
        # Get table information for all tables for which we will create/update
        # archive tables.
        @tables_desc = map { $self->get_table_desc( $_ ) } @{ $self->{tables} };
    } else {
        @tables_desc = $self->find_data_tables_with_revision( );
    }

    # Check that all source tables have required columns.
    for my $table ( @tables_desc ) {
        $self->check_table_is_archive_capable( $table );
    }

    # Basic checks done, we should be good to go to start making and updating
    # tables.
    for my $table ( @tables_desc ) {
    
        # Make archive table description from source data table
        my $archive_table = $self->make_archive_table_desc( $table );
    
        # Check if there is a current archive table.
        my $current_archive_table;
        eval { $current_archive_table = $self->get_table_desc( $archive_table->{name} ) };
    
        if( $current_archive_table ) {
            # Check if any updates are required.
            print "Archive table `$current_archive_table->{name}` found for `$table->{name}`.\n"
                if $VERBOSE;

            # Verify that the current archive table could be updated to new requirements.
            $self->check_table_updatable( $current_archive_table, $archive_table );

            # Update the archive table definition.
            $self->write_table_definition( $archive_table );
        } else {
            print "Writing archive table `$archive_table->{name}` definition for `$table->{name}`.\n"
                if $VERBOSE;
            $self->write_table_definition( $archive_table );
        }

        $self->write_archive_trigger_fragments( $table, $archive_table );
    }
}

=back

=head1 AUTHOR

Johnathan Kupferer <jtk@uic.edu>

=head1 COPYRIGHT

Copyright (C) 2015 The University of Illinois at Chicago. All Rights Reserved.

This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

1;
